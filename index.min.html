<!doctype html>
<meta charset=utf-8>
<body id=b>
<script>


// MINI JS BEAUTIFIER

// Goal: write a tiny JS beautifier that relies heavily on replaces and regular expressions, and aimed at minified and/or packed code

// We want to identify and isolate comments, strings, regexes and divisions, before beautifying the rest of the JS code. But these elements are ambiguous: 
// Indeed, it's hard to tell is a slash is the start of a comment, the start of a regex, a division sign, or just a character in a string.
// Or to tell if a (double-)quote is the start of a string, a character inside a string, a character in a comment or a character in a regex.
// Or to tell if an antislash is part of a string or a regex (as a char or as an escape character), or a character in a comment.
// We also don't want to beautify the text inside a string, a comment or a RegEx as if it was real JS code.
// The solution is to make a loop, and at each iteration, see which character (slash, quote or double quote) comes first,
// Then use the characters around to decide if it's a division sign or the start of a string, a regex, or a comment,
// Then isolate the string / regex / comment / divisor sign, and replace it temporarly with a token.
// Repeat until no more slashes or (double-)quotes are found.
// The tokens will be replaced with their original values later.


b.innerHTML="<textarea rows=40 cols=99 id=p>";

oninput=function(){

/* ==== comments, regexes and divisions  ===== */

j=p.value;  // JS code to beautify
c=[]; // comments
s=[]; // strings
r=[]; // regexes
d=e=f=g=h=o=0; // counters


// Loop while the code is changed inside the loop
for(;o!=j;){

  // Backup js code
  o = j;

  // Find first ' or " or /
  // and if it's a slash
  if((k=j.match(/['"\/]/))=="/"){

    // Take all the chars preceding the slash
    l=j.indexOf(k);
    n=j.slice(0,l+1);
    
    // Isolate comment if slash is followed by "/" or "*"
    if(j[l+1].match(/[\/*]$/)){
      j=j.replace(/\/\/.*|\/\*[^]*?\*\//,function(a){c.push(a);return"@C"+(e++)+"@"})
    }
    
    // Identify a regex if:
    // - It's not a division (it's a division if slash follows a digit, a variable, a boolean, ")",  "}", "]", null, undefined, this (plus optional spaces / line jumps / comments))
    // - It's a regex (slash at the start of the js code or follows an operator, ",", ";", "[", "(", or a keyword from this list, (plus optional spaces / line jumps / comments / division)):
    // case delete else return throw yield debugger continue break throw return
    else if(
      !n.match(/([\d\)\]\}]|true|false|null|undefined|this|@S\d+@)\s*(@C\d+@)*\s*\//im)
      && n.match(/([-,;=><+%*&|^~!?!:\[\(]|delete|typeof|void|in|instanceof|of|case|delete|else|return|throw|yield|debugger|continue|break|throw|return|@D@|^)\s*(@C\d+@)*\s*\//m)
    ){
      j=j.replace(/\/(\\\\|\\\/|[^\/])+?\/[gimuy]*/,function(a){r.push(a);return"@R"+(g++)+"@"})
    }
    
    // Unknown case (assume it's a division)
    else{
      j=j.replace("/","@D@");
    }
  }
  
  // Isolate strings, including escape sequences
  else if(k=="'"){
    j=j.replace(/'(\\\\|\\'|[^'])*?'/,function(a){s.push(a);return"@S"+(h++)+'@'})
  }
  else{
    j=j.replace(/"(\\\\|\\"|[^"])*?"/,function(a){s.push(a);return"@S"+(h++)+'@'})
  }
  
  p.value=j;
}

/* ===== end ===== */

// Reformat the rest:

// Clean line breaks
j=j.replace(/[\r\n]+ */g,"\n")

// reduce spaces
j=j.replace(/ +/g," ")

// Ensure there are spaces around some operators (including "/" and "/=" while the division sign is replaced by @D@)
j=j.replace(/ *(@D@=?|[+\-\*%=&\|:?<>^]+) */g," $1 ")

// Add spaces after some operators
j=j.replace(/ *([,]) */g,"$1 ")

// Add line jumps after some operators
j=j.replace(/ *([;\{\}]) */g,"$1\n")

// Put for loops on one line
j=j.replace(/for\s*\([^;]*?;[^;]*?;[^]/g,function(a){return a.replace(/\n/g,"").replace(/;/g,"; ")})

// Ensure "}" are on a new line
j=j.replace(/}/g,"\n}")

// Line break after "case ..." : or "default :"
j=j.replace(/(case|default).*?: */g,"$&\n")

// Reindent lines
j=j.replace(/.*?([\{\}])?\n/g,function(a,b){b+="";if(b[0]=="{"){return"  ".repeat(d++)+a}else if(b[0]=="}"){d--}return"  ".repeat(d)+a})

// Put back comments
j=j.replace(/@C(\d+)@/g,function(a,b){return c[b]})


// Put back strings
j=j.replace(/@S(\d+)@/g,function(a,b){return s[b]})

// Put back regexes
j=j.replace(/(@R\d@) \)/g,"$1)")
j=j.replace(/@R(\d+)@/g,function(a,b){return r[b]})

// Put back divisions
j=j.replace(/ *@D@ */g," / ")
j=j.replace(/\/ =/g,"/=")


// Various cleanups
j=j.replace(/}\n *,/g,"},")
j=j.replace(/\{\n\s*\}/g,"{}")
j=j.replace(/,,/g,", ,")
j=j.replace(/(=>?){/g,"$1 {")
j=j.replace(/(!+)\s+/g,"$1")
j=j.replace(/\)([^ ({];)/g,") $1")
j=j.replace(/ (\+\+|--) *(\))/g,"$1$2")
j=j.replace(/(\+\+|--) ([,;&|=<>])/g,"$1$2")
j=j.replace(/([\n\)] *\+\+|--) /g,"$1")
j=j.replace(/([,;&|=<>]) (\+\+|--)/g,"$1$2")

// Clean line breaks again
j=j.replace(/\s*\n/g,"\n")

// Misc
j=j.replace(/\n *;\n/g,";\n")
j=j.replace(/}\n *\)((\(\))?;?)\n/g,"})$1\n")
j=j.replace(/([\(\{\[]|case ) *([-+]) *(\d)/g,"$1$2$3")
j=j.replace(/(if|while) \(/g,"if(")
j=j.replace(/\( *([\w\d]*) *\)/g,"($1)")
j=j.replace(/}\n *([\]:])/g,"}$1")

// Output
p.value=j;

}

onload=function(){
  p.value=tests.innerHTML;
  oninput();
}

</script>

<script type=tests id=tests>/regex_at_the_beginning/;

1;
// comment

// comment with "string" 'string' /regex/ slash: /, doubleslash: //, quotes: "', /*comment*/ anything: \\\/////\/\//////\\\n

/* comment */

/* multiline
comment */

2;

'';

'string';

"string";

"escaped\"doublequote";

'escaped\'quote';

"not escaped doublequote \\";

'not escaped quote \\';

' string with quotes ", escapes: \', /regex/, /* comments */, // comments'

"string with quotes ', escapes: \", /regex/, /* comments */, // comments"

"\\\\"

'\\\\'

"escaped \
newline"

'escaped\
newline'

3;

1/2

a / b

4;

/regex/;

/regex/gumiy;

/regex with \/ escape \\\/ escape "string" 'string'/;

/ /;

/\\\\/;

// /[a/b]/


5;

/0//0

/1/ /regex/ /"string/"// <-- comment starts here /

0/ /regex//1// <-- comment starts here

/2/ /* comment *//1/g// <-- comment starts here

// hmm

if ('this_is'==/an_example/){of_beautifier();}else{var a=b?(c%d):e[f];}
for (var line=1; line<30; line++) {
for(var i=1;i<29;i++) {
var s = (Math.floor((Math.random()*2)%2)) ? "?" : "?";
document.write(s);
document.writeln("<br>");
}}
{a:1, b:2}
var a=1, b=c[d], e=6;
for(var a=1,b=2,c=3;d<3;d++)e
for(var a=1,b=2,c=3;d<3;d++)e
function foo() {    return [        "one","two"    ];}
a=[[1,2],[4,5],[7,8]]
a=[[1,2],[4,5],[7,8],]
a=[[1,2],[4,5],function(){},[7,8]]
a=[[1,2],[4,5],function(){},function(){},[7,8]]
a=[[1,2],[4,5],function(){},[7,8]]
a=[b,c,function(){},function(){},d]
a=[b,c,function(){},function(){},d]
a=[a[1],b[4],c[d[7]]]
[1,2,[3,4,[5,6],7],8]
[[["1","2"],["3","4"]],[["5","6","7"],["8","9","0"]],[["1","2","3"],["4","5","6","7"],["8","9","0"]]]
if(p) foo(a,b);
try{while(true){willThrow()}}catch(result)
switch(result){case 1:++result }
((e/((a+(b)*c)-d))^2)*5;
function f(a,b) {if(a) b()}function g(a,b) {if(!a) b()}
a=[];
a=[b,c,d];
a= f[b];




async function foo() {}
let w = async function foo() {}
async function foo() {}var x = await foo();
wrapper(async function foo() {})
async function() {    var w = await(async function() {        return await foo();    })();}
async.map(function(t) {})
var a =  1;/* beautify preserve:start */   var a = 1;/* beautify preserve:end */
var a = 1; /* beautify preserve:start */   var a = 1;/* beautify preserve:end */
a=typeof(x)
x();function(){}
x();var x = {x: function(){}}
function () {    var a, b, c, d, e = [],        f;}
switch(x) {case 0: case 1: a(); break; default: break}
switch(x){case -1:break;case !y:break;}
fragment: true,
var a2, b2, c2, d2 = 0, c = function() {}, d = '';
var a2, b2, c2, d2 = 0, c = function() {},d = '';
var o2=$.extend(a);function(){alert(x);}
function*() {    yield 1;}
(function() {if (!window.FOO) window.FOO || (window.FOO = function() {var b = {bar: "zort"};});})();
if(x){a();}else{b();}if(y){c();}
if (x) {
    a();
} else {
    b();
if (y) {
    c();
}}


a        =          1
a=1
["a", "b"].join("")
var a = 1 var b = 2
var a=1, b=c[d], e=6;
let a = 1 let b = 2
let a=1, b=c[d], e=6;
const a = 1 const b = 2
const a=1, b=c[d], e=6;
if(1){2}else{3}
if(1||2);
(a==1)||(b==2)
var a = 1 if (2) 3;
/12345[^678]*9+/.match(a)
a<.5
a<=.5
a=0e-12345.3e-10
a=0.e-12345.3e-10
a=0x.e-12345.3e-10
a=0x0.e-12345.3e-10
a=0x0.0e-12345.3e-10
a=0g-12345.3e-10
a=0.g-12345.3e-10
a=0x.g-12345.3e-10
a=0x0.g-12345.3e-10
a=0x0.0g-12345.3e-10
a=030e-5
a=00+4
a=32+4
a=0.6g+4
a=01.10
a=a.10
a=00B0x0
a=00B0xb0
a=00B0x0b0
a=0090x0
a=0g0b0o0
a=0x30e-5
a=0xF0+4
a=0Xff+4
a=0Xffg+4
a=0x01.10
a=0x0B0x0
a=0x0B0xb0
a=0x0B0x0b0
a=0X090x0
a=0Xg0b0o0
a=0o30e-5
a=0o70+4
a=0O77+4
a=0O778+4
a=0O77a+4
a=0o01.10
a=0o0B0x0
a=0o0B0xb0
a=0o0B0x0b0
a=0O090x0
a=0Og0b0o0
a=0b10e-5
a=0b10+4
a=0B11+4
a=0B112+4
a=0B11a+4
a=0b01.10
a=0b0B0x0
a=0b0B0xb0
a=0b0B0x0b0
a=0B090x0
a=0Bg0b0o0



F*(g/=f)*g+b
a.b({c:d})
a.b({c:d})
a.b({c:"d"})
a.b({c:"d"})
a=!b
a=!!b
a?b:c
a?1:2
a?(b):c
x={a:1,b:w=="foo"?x:y,c:z}
x=a?b?c?d:e:f:g;
x=a?b?c?d:{e1:1,e2:2}:f:g;
function void(void) {}
if(!a)foo();
a=~a
a;/*comment*/b;
a;/* comment */b;
a;/*** javadoc*/b;
a;/** javadoc*/b;
if(a)break;
if(a){break}
if((a))foo();
for(var i=0;;) a
for(var i=0;;)a
for(;;i++)a()
for(;;i++)a()
for(;;++i)a
return(1)
try{a();}catch(b){c();}finally{d();}
(xx)()
a[1]()
if(a){b();}else if(c) foo();
switch(x) {case 0: case 1: a(); break; default: break}
switch(x){case -1:break;case !y:break;}
a !== b
if (a) b(); else c();


$http().then().finally().default()
$http().when.in.new.catch().throw()
{xxx;}()
{/abc/i.test()}
var x=(a)/a;
for (; s-- >0;)t
for (; s++>0;)u
a = s++>s--;
a = s++>--s;
{x=#1=[]}
{a:#1={}}
{a:#1#}
{a:#1=[],b:#1#,c:#999999#}
do{x()}while(a>1)
x(); /reg/exp.match(something)
function namespace::something()
{foo();--bar;}
{foo();++bar;}
{--bar;}
{++bar;}
if(true)++a;
if(true)++a;
if(true)--a;
if(true)--a;
a=[[1,2],[4,5],[7,8]]
a=[[1,2],[4,5],function(){},[7,8]]
a=[[1,2],[4,5],function(){},function(){},[7,8]]
a=[[1,2],[4,5],function(){},[7,8]]
a=[b,c,function(){},function(){},d]
a=[b,c,function(){},function(){},d]
a=[a[1],b[4],c[d[7]]]
[1,2,[3,4,[5,6],7],8]
[[["1","2"],["3","4"]],[["5","6","7"],["8","9","0"]],[["1","2","3"],["4","5","6","7"],["8","9","0"]]]
{[x()[0]];indent;}
return [1,2]
catch(e)
var a=1,b={foo:2,bar:3},{baz:4,wham:5},c=4;
var a=1,b={foo:2,bar:3},{baz:4,wham:5},c=4;
function x(/*int*/ start, /*string*/ foo)
/*** foo*/
{/*** foo*/}
{/**foo*/}
{/**foo**/}
{/**foobar**/}
{/**foobar**/}
{/**foo    bar**/}
var a,b,c=1,d,e,f=2;
var a,b,c=[],d,e,f=2;
do/regexp/;while(1);
var a = a,a;
a=typeof(x)
var whatever = require("whatever");function() {    a = 6;}
var whatever = require("whatever")function() {    a = 6}
{"x":[{"a":1,"b":3},7,8,8,8,8,{"b":99},{"a":11}]}
{"x":[{"a":1,"b":3},7,8,8,8,8,{"b":99},{"a":11}]}
{"1":{"1a":"1b"},"2"}
{a:{a:b},c}
{[y[a]];keep_indent;}
if (x) {y} else { if (x) {y}}
var a=1,b={bang:2},c=3;
var a={bing:1},b=2,c=3;

</script>